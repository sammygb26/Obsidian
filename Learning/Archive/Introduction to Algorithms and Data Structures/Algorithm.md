# Algorithm
### What are algorithms?
Algorithms are like recipes for solving problems in computing. If we have some standard problem, we can use a standard algorithm or a variation of it to solve that problem. Knowing the most suitable algorithm is part of being a good programmer. An algorithm is only **correct** if it solves the problem it is designed for, for every possible input sequence.

Some example of problems solved by algorithms are [[Sorting]] (names into order), finding the fastest path to some point ([[Graph]] Traversal), finding longest common substring and so on. An algorithm's usefulness is defined by  [[Algorithm Efficiency]]  which is a measure of how efficient in space or time an algorithm is.

### History
Algorithms were used even before computers when people had to do al arithmetic by hand. The word in fact comes from a man called Muhammed al-Khwarizmi. So algorithms are very old despite computers use of them being recent.

### Importance
To get computers to run faster there are many ways. Hardware so processing speed, parallel processing, and compiler techniques (optimization of machine code). But another way is advances in Algorithms and data structures.

## Greedy Algorithms
A **greedy** algorithm always does was it best in the short term picking the best options. This is a strategy the big picture isn't considered only the small scale options. So for a coin system (where we want to find the minimum number of coins that can make up some amount) the best option is just to pick the largest coins first

## Designing Algorithms
There are many ways to design algorithms such as an incremental approach such as in [[Insert Sort]]. There is also the [[Recursion]] approach with divide and conquer approach and [[Dynamic Programming]] approach where in both cases we represent a problem with a recursion where we can find it from some simpler smaller case.

**Divide-and-conquer** -> This has three main steps. *Divide* where we break a problem down into sub problems with [[Recursion]]. *Conquer* where using the recursion be continuously break the problem down until we reach some floor or base case. *Combine* we then work back up combining these elements.

[[Algorithm Questions]]
[[Sorting Algorithms Questions]]